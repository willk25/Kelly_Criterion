####
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple

def kelly_criterion_newton(odds: List[float], probabilities: List[float], 
                         initial_value: float = 0.25, threshold: float = 1e-6) -> Tuple[float, float]:
    """
    Calculate optimal Kelly Criterion fraction using Newton's method for multiple outcomes.
    
    Args:
        odds: List of potential returns (can be negative)
        probabilities: List of probabilities for each outcome
        initial_value: Starting point for Newton's method
        threshold: Convergence threshold
    
    Returns:
        Tuple of (optimal_fraction, expected_value)
    """
    # Convert inputs to numpy arrays
    b = np.array(odds)
    p = np.array(probabilities)
    
    # Normalize probabilities to sum to 1
    p = p / np.sum(p)
    
    # Check if portfolio is profitable
    if np.sum(b * p) <= 0:
        return 0.0, 0.0
    
    past_value = 0
    next_value = initial_value
    bump_occurred = False
    
    # Newton's method iteration
    while abs(past_value - next_value) > threshold:
        past_value = next_value
        
        # Calculate numerator and denominator for Newton's step
        numerator = np.sum(p * b / (1 + b * past_value))
        denominator = np.sum(-b**2 * p / (1 + b * past_value)**2)
        
        next_value = past_value - numerator/denominator
        
        # Ensure we don't go negative
        if next_value < 0 and not bump_occurred:
            next_value = 0
            bump_occurred = True
    
    # Calculate expected value
    expected_value = np.exp(np.sum(p * np.log(1 + b * next_value)))
    
    return next_value, expected_value

def plot_kelly_landscape(odds: List[float], probabilities: List[float], optimal_f: float):
    """
    Create visualization of the Kelly Criterion optimization landscape.
    
    Args:
        odds: List of potential returns
        probabilities: List of probabilities for each outcome
        optimal_f: Optimal fraction calculated by Newton's method
    """
    x = np.linspace(0, min(1, optimal_f*2), 1000)  # Adjust range based on optimal value
    y = [np.exp(np.sum(np.array(probabilities) * np.log(1 + np.array(odds) * f))) for f in x]
    
    plt.figure(figsize=(12, 6))
    plt.plot(x, y, 'b-', label='Expected Value')
    plt.axvline(x=optimal_f, color='r', linestyle='--', label=f'Optimal f = {optimal_f:.3f}')
    plt.plot(optimal_f, np.exp(np.sum(np.array(probabilities) * np.log(1 + np.array(odds) * optimal_f))), 
             'ro', label=f'Maximum EV = {max(y):.3f}')
    
    plt.title('Kelly Criterion Optimization Landscape')
    plt.xlabel('Fraction of Bankroll (f)')
    plt.ylabel('Expected Value (exp of sum)')
    plt.grid(True)
    plt.legend()
    plt.show()

def main():
    """
    Main function to run the Kelly Criterion calculator with user inputs.
    """
    print("Kelly Criterion Calculator for Multiple Outcomes")
    print("----------------------------------------------")
    
    # Get number of outcomes
    n = int(input("Enter number of outcomes: "))
    
    odds = []
    probabilities = []
    
    # Get odds and probabilities for each outcome
    for i in range(n):
        print(f"\nOutcome {i+1}:")
        odd = float(input(f"Enter return for outcome {i+1} (e.g., -1 for loss, 2 for 2:1 return): "))
        prob = float(input(f"Enter probability for outcome {i+1} (e.g., 0.5 for 50%): "))
        
        odds.append(odd)
        probabilities.append(prob)
    
    # Calculate optimal fraction and expected value
    optimal_fraction, expected_value = kelly_criterion_newton(odds, probabilities)
    
    print("\nResults:")
    print(f"Optimal Kelly fraction: {optimal_fraction:.3f}")
    print(f"Expected value at optimal fraction: {expected_value:.3f}")
    
    # Create visualization
    plot_kelly_landscape(odds, probabilities, optimal_fraction)

if __name__ == "__main__":
    main()
###
